import pandas as pd

# Шаг 1 Загружаем базовый датасет с полными данными в котором организации отобраны по статусу Действующее
# Для ускорения работы отобраны только 2 колонки, также чтобы не убирались лидирующие нули, колонке ИНН принудительно поставлен тип str
base_df = pd.read_excel('resources/test_existing_org.xlsx', usecols=['Организация', 'ИНН'], dtype={'ИНН': str})
# Шаг 2 Создаем  датафрейм куда будем добавлять полученные данные
df = pd.DataFrame(columns=['Название', 'ИНН', 'Внеоборотные активы 2018','Внеоборотные активы 2019','Внеоборотные активы 2020',
                           'Оборотные активы 2018','Оборотные активы 2019','Оборотные активы 2020','Капитал и резервы 2018',
                           'Капитал и резервы 2019','Капитал и резервы 2020','Долгосрочные обязательства 2018','Долгосрочные обязательства 2019',
                           'Долгосрочные обязательства 2020','Краткосрочные обязательства 2018','Краткосрочные обязательства 2019','Краткосрочные обязательства 2020',
                           'Совокупный финансовый результат 2018','Совокупный финансовый результат 2019','Совокупный финансовый результат 2020'],)

# Создаем словарь необходимых показателей
dct_indicators = {'Ф1.1100': 'Внеоборотные активы', 'Ф1.1200': 'Оборотные активы', 'Ф1.1300': 'Капитал и резервы',
                  'Ф1.1400': 'Долгосрочные обязательства', 'Ф1.1500': 'Краткосрочные обязательства',
                  'Ф2.2500': 'Совокупный финансовый результат'}
# Шаг 3.	Итерируемся по датасету, переменной будет выступать ИНН.Используем itertuples, так как он проще для понимания
# Обрабатываем случаи

for row in base_df.itertuples():
    # row[1] это название организации
    # row[2] ИНН
    # Для удобства создадаем словарь который потом будем добавлять в итоговый датафрейм как строку.
    row_df = {}

    row_df['Название'] = row[1]
    row_df['ИНН'] = row[2]
    try:
        # Считываем файл, пропускаем заголовок Финансовая (бухгалтерская) отчетность по данным ФНС и Росстата:
        single_df = pd.read_excel(f'resources/fin_data/{row[2]}.xlsx', skiprows=1)
        # Удаляем колонку с обозначением денежных единиц, по умолчанию там все считается в тысячах
        single_df.drop(inplace=True, axis=1, columns=['Unnamed: 2'])
        # Удаляем строки где есть слово Код
        single_df.dropna(inplace=True, axis=0, how='all')
        # Убираем строки где есть слово Код, так как они мешают
        single_df = single_df[single_df['Код'] != 'Код']
        # Делаем признак Код индексом, чтобы потом получать значения ячеек
        single_df.set_index('Код', inplace=True)

        # Превращаем строку в словарь чтобы использовать get, так как данных за 2019 или другой год вполне может не быть
        for key, value in dct_indicators.items():
            temp_dict = single_df.loc[f'{key}'].to_dict()
            row_df[f'{value} 2018'] = temp_dict.get(2018, 0)
            row_df[f'{value} 2019'] = temp_dict.get(2019, 0)
            row_df[f'{value} 2020'] = temp_dict.get(2020, 0)
        print(row_df)


        # Промежуточное сохранение для самоконтроля
        single_df.to_excel(f'resources/temp/{row[2]}.xlsx')

        df = df.append(row_df, ignore_index=True)
        print(df)
    except FileNotFoundError:
        with open('resources/fin_data/errors.txt', encoding='cp1251', mode='a') as f:
            f.write(f'{row[1]} - {row[2]} \n')

# Экспортируем в Excel
df.to_excel('resources/finance.xlsx', index=False)
